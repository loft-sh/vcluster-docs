---
title: Embedded etcd
sidebar_label: embedded
sidebar_position: 2
sidebar_class_name: pro
description: Configure an embedded etcd instance as the virtual cluster's backing store.
---

import ConfigReference from '../../../../../../_partials/config/controlPlane/backingStore/etcd/embedded.mdx'
import ProAdmonition from '../../../../../../_partials/admonitions/pro-admonition.mdx'
import BackingStoreMigration from '../../../../../../_partials/config/controlPlane/backingStore/backing-store-migration.mdx'
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<ProAdmonition/>

When using this backing store option, etcd is deployed as part of the vCluster control plane pod to reduce the overall footprint.

<BackingStoreMigration/>

```yaml
controlPlane:
  backingStore:
    etcd:
      embedded:
        enabled: true
```

## How embedded etcd works

Embedded etcd starts the etcd binary with the Kubernetes control plane inside the vCluster pod. This enables vCluster to run in high availability (HA) scenarios without requiring a separate `StatefulSet` or `Deployment`.

vCluster fully manages embedded etcd and provides these capabilities:

- **Dynamic scaling**: Scales the etcd cluster up or down based on vCluster replica count.
- **Automatic recovery**: Recovers etcd in failure scenarios such as corrupted members.
- **Seamless migration**: Migrates from SQLite or deployed etcd to embedded etcd automatically.
- **Simplified deployment**: Requires no additional `StatefulSets` or `Deployments`.

<!-- vale off -->
## Scaling behavior

vCluster dynamically builds the etcd cluster based on the number of desired replicas. For example, when you scale vCluster from 1 to 3 replicas, vCluster automatically adds the new replicas as members to the existing single-member cluster. Similarly, vCluster removes etcd members when you scale down the cluster.

When scaling down breaks quorum (such as scaling from 3 to 1 replicas), vCluster rebuilds the etcd cluster without data loss or interruption. This enables dynamic scaling up and down of vCluster.

## Disaster recovery

When embedded etcd encounters failures, vCluster provides both automatic and manual recovery options to restore cluster capabilities.

### Automatic recovery

vCluster recovers the etcd cluster automatically in most failure scenarios by removing and readding the failing member. Automatic recovery occurs in these cases:

- **Unresponsive member**: Etcd member is unresponsive for more than 2 minutes.
- **Detected issues**: Corruption or another alarm is detected on the etcd member.

vCluster attempts to recover only a single replica at a time. If recovering an etcd member results in quorum loss, vCluster does not recover the member automatically.

### Manual recovery

#### Recover a single replica

When a single etcd replica fails, vCluster can recover the replica automatically in most cases, including:

- Replica database corruption
- Replica database deletion
- Replica PVC deletion
- Replica removal from etcd cluster using `etcdctl member remove ID`
- Replica stuck as a learner

If vCluster cannot recover the single replica automatically, wait at least 10 minutes before deleting the replica pod and PVC. This action causes vCluster to rejoin the etcd member.

#### Recover the entire cluster

In rare cases, the entire etcd cluster requires manual recovery. This occurs when the majority of etcd member replicas become corrupted or deleted simultaneously (such as 2 of 3, 3 of 5, or 4 of 7 replicas). In this scenario, etcd fails to start and vCluster cannot recover automatically.

:::note
Normal pod restarts or terminations do not require manual recovery. These events trigger automatic leader election within the etcd cluster.
:::

Recovery procedures depend on whether the first replica (the pod ending with `-0`) is among the failing replicas:

<Tabs>
<TabItem value="first-replica-working" label="First replica is not failing">

1. Scale down the vCluster `StatefulSet` to a single replica
2. vCluster rebuilds a single-replica etcd cluster
3. After vCluster is running, scale up to the desired number of replicas

</TabItem>
<TabItem value="first-replica-failing" label="First replica is failing">

1. Scale down vCluster to 0 replicas
2. Delete the `PersistentVolumeClaim` of the first replica
3. [Copy the `PersistentVolumeClaim`](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#volume-cloning) from a working replica to the first replica `PersistentVolumeClaim`
4. Scale up vCluster to a single replica

</TabItem>
<TabItem value="complete-data-loss" label="Complete data loss scenario">

If all replicas are damaged or corrupted, recover from a snapshot or backup.

</TabItem>
</Tabs>

## Config reference

<ConfigReference/>
