---
title: Embedded etcd
sidebar_label: embedded
sidebar_position: 2
sidebar_class_name: pro host-nodes private-nodes standalone
description: Configure an embedded etcd instance as the virtual cluster's backing store.
---

import ConfigReference from '../../../../../../_partials/config/controlPlane/backingStore/etcd/embedded.mdx'
import ProAdmonition from '../../../../../../_partials/admonitions/pro-admonition.mdx'
import InterpolatedCodeBlock from "@site/src/components/InterpolatedCodeBlock";
import Flow, { Step } from '@site/src/components/Flow';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Admonition from '@theme/Admonition';
import TenancySupport from '../../../../../../_fragments/tenancy-support.mdx';

<TenancySupport hostNodes="true" privateNodes="true" standalone="true"/>

<ProAdmonition/>

:::warning Upgrade Notice

An issue exists when upgrading etcd (from version 3.5.1 or later, but earlier than 3.5.20) to version 3.6. This upgrade path can lead to a failed upgrade and cause the virtual cluster to break. etcd version 3.5.20 includes a fix that migrates membership data to the v3 data store. This migration prevents the issue when upgrading to version 3.6.

To avoid this issue, vCluster does not upgrade etcd to version 3.6 until vCluster version 0.29.0.

Any vCluster running a version earlier than 0.24.2, must first be upgraded to a version between 0.24.2 and 0.28.x, before upgrading to version 0.29.0.

For more information, see the [official etcd documentation](https://etcd.io/blog/2025/upgrade_from_3.5_to_3.6_issue/).
:::

When using this backing store option, etcd is deployed as part of the vCluster control plane pod to reduce the overall footprint.

```yaml
controlPlane:
  backingStore:
    etcd:
      embedded:
        enabled: true
```

## How embedded etcd works

Embedded etcd starts the etcd binary with the Kubernetes control plane inside the vCluster pod. This enables vCluster to run in high availability (HA) scenarios without requiring a separate `StatefulSet` or `Deployment`.

vCluster fully manages embedded etcd and provides these capabilities:

- **Dynamic scaling**: Scales the etcd cluster up or down based on vCluster replica count.
- **Automatic recovery**: Recovers etcd in failure scenarios such as corrupted members.
- **Seamless migration**: Migrates from SQLite or [deployed etcd](../../../../../../manage/migrate-etcd-backing-store) to embedded etcd automatically.
- **Simplified deployment**: Requires no additional `StatefulSets` or `Deployments`.

<!-- vale off -->
## Scaling behavior

vCluster dynamically builds the etcd cluster based on the number of desired replicas. For example, when you scale vCluster from 1 to 3 replicas, vCluster automatically adds the new replicas as members to the existing single-member cluster. Similarly, vCluster removes etcd members when you scale down the cluster.

When scaling down breaks quorum (such as scaling from 3 to 1 replicas), vCluster rebuilds the etcd cluster without data loss or interruption. This enables dynamic scaling up and down of vCluster.

## Disaster recovery

When embedded etcd encounters failures, vCluster provides both automatic and manual recovery options to restore cluster capabilities.

### Automatic recovery

vCluster recovers the etcd cluster automatically in most failure scenarios by removing and readding the failing member. Automatic recovery occurs in these cases:

- **Unresponsive member**: Etcd member is unresponsive for more than 2 minutes.
- **Detected issues**: Corruption or another alarm is detected on the etcd member.

vCluster attempts to recover only a single replica at a time. If recovering an etcd member results in quorum loss, vCluster does not recover the member automatically.

### Manual recovery

#### Recover a single replica

When a single etcd replica fails, vCluster can recover the replica automatically in most cases, including:

- Replica database corruption
- Replica database deletion
- Replica `PersistentVolumeClaim` (PVC) deletion
- Replica removal from etcd cluster using `etcdctl member remove ID`
- Replica stuck as a learner

If vCluster cannot recover the single replica automatically, wait at least 10 minutes before deleting the replica pod and PVC. This action causes vCluster to rejoin the etcd member.

#### Recover the entire cluster

In rare cases, the entire etcd cluster requires manual recovery. This occurs when the majority of etcd member replicas become corrupted or deleted simultaneously (such as 2 of 3, 3 of 5, or 4 of 7 replicas). In this scenario, etcd fails to start and vCluster cannot recover automatically.

:::note
Normal pod restarts or terminations do not require manual recovery. These events trigger automatic leader election within the etcd cluster.
:::

Recovery procedures depend on whether the first replica (the pod ending with `-0`) is among the failing replicas.

Use the following procedures when some replicas are still functioning:
<br />

<Tabs>
<TabItem value="first-replica-working" label="First replica is not failing">

<Flow>
<Step title="Scale down the vCluster StatefulSet to a single replica">
Scale the StatefulSet to one replica:

<InterpolatedCodeBlock 
  code={`kubectl scale statefulset [[VAR:VCLUSTER NAME:my-vcluster]] --replicas=1 -n [[VAR:NAMESPACE:vcluster-my-team]]`}
  language="bash"
/>

<br />

Verify only one pod is running:

<InterpolatedCodeBlock 
  code={`kubectl get pods -l [[VAR:VCLUSTER LABEL:app=vcluster]] -n [[VAR:NAMESPACE:vcluster-my-team]]`}
  language="bash"
/>
</Step>

<Step title="Monitor the etcd cluster rebuild">
Monitor the rebuild process:

<InterpolatedCodeBlock 
  code={`kubectl logs -f [[VAR:VCLUSTER NAME:my-vcluster]]-0 -n [[VAR:NAMESPACE:vcluster-my-team]]`}
  language="bash"
/>

<br />

Watch for log messages indicating etcd is ready and the cluster is in good condition.
</Step>

<Step title="Scale up to the desired number of replicas">
Scale back up to your target replica count:

<InterpolatedCodeBlock 
  code={`kubectl scale statefulset [[VAR:VCLUSTER NAME:my-vcluster]] --replicas=[[VAR:DESIRED REPLICA COUNT:3]] -n [[VAR:NAMESPACE:vcluster-my-team]]`}
  language="bash"
/>

<br />

Verify all replicas are running:

<InterpolatedCodeBlock 
  code={`kubectl get pods -l [[VAR:VCLUSTER LABEL:app=vcluster]] -n [[VAR:NAMESPACE:vcluster-my-team]]
kubectl logs [[VAR:VCLUSTER NAME:my-vcluster]]-0 -n [[VAR:NAMESPACE:vcluster-my-team]] | grep "cluster is ready"`}
  language="bash"
/>
</Step>
</Flow>

</TabItem>

<TabItem value="first-replica-failing" label="First replica is failing">

:::warning
Before attempting any recovery procedure, create a backup of the virtual cluster namespace on the host cluster. If using namespace syncing, back up all synced namespaces as well.
:::

The recovery procedure depends on your StatefulSet `podManagementPolicy` configuration. vCluster version 0.20 and later use `Parallel` by default. Earlier versions used `OrderedReady`.

Check your configuration:

<InterpolatedCodeBlock
  code={`kubectl get statefulset [[VAR:VCLUSTER NAME:my-vcluster]] -n [[VAR:NAMESPACE:vcluster-my-team]] -o jsonpath='{.spec.podManagementPolicy}'`}
  language="bash"
/>

<Tabs groupId="pod-management-policy">
<TabItem value="parallel" label="Parallel (default)">

<Flow>
<Step title="Delete the failed pod and PVC">
Delete the corrupted pod and PVC for replica-0:

<InterpolatedCodeBlock
  code={`kubectl delete pod [[VAR:VCLUSTER NAME:my-vcluster]]-0 -n [[VAR:NAMESPACE:vcluster-my-team]]
kubectl delete pvc [[VAR:PVC PREFIX:data]]-[[VAR:VCLUSTER NAME:my-vcluster]]-0 -n [[VAR:NAMESPACE:vcluster-my-team]]`}
  language="bash"
/>

<br />

The pod restarts with a new empty PVC. After 1-3 pod restarts, the automatic recovery adds it back to the etcd cluster.
</Step>

<Step title="Monitor recovery">
Monitor the recovery process:

<InterpolatedCodeBlock
  code={`kubectl get pods -l [[VAR:VCLUSTER LABEL:app=vcluster]] -n [[VAR:NAMESPACE:vcluster-my-team]] -w`}
  language="bash"
/>

<br />

Check the logs to verify the pod rejoins successfully:

<InterpolatedCodeBlock
  code={`kubectl logs -f [[VAR:VCLUSTER NAME:my-vcluster]]-0 -n [[VAR:NAMESPACE:vcluster-my-team]]`}
  language="bash"
/>
</Step>
</Flow>

</TabItem>

<TabItem value="ordered-ready" label="OrderedReady (legacy)">

:::caution
If more than one pod is down with `podManagementPolicy: OrderedReady`, migrate to `Parallel` first before attempting recovery.
:::

<Flow>
<Step title="Verify PVC retention policy">
Check that the StatefulSet retains PVCs on deletion:

<InterpolatedCodeBlock
  code={`kubectl get statefulset [[VAR:VCLUSTER NAME:my-vcluster]] -n [[VAR:NAMESPACE:vcluster-my-team]] -o jsonpath='{.spec.persistentVolumeClaimRetentionPolicy}'`}
  language="bash"
/>

<br />

The policy should be `Retain`. This is the default but can be overridden by `controlPlane.statefulSet.persistence.volumeClaim.retentionPolicy` in your configuration.
</Step>

<Step title="Delete the StatefulSet">
Delete the StatefulSet without deleting the pods:

<InterpolatedCodeBlock
  code={`kubectl delete statefulset [[VAR:VCLUSTER NAME:my-vcluster]] -n [[VAR:NAMESPACE:vcluster-my-team]] --cascade=orphan`}
  language="bash"
/>
</Step>

<Step title="Update configuration to Parallel">
Update your virtual cluster configuration to use `Parallel` pod management policy.

If using a VirtualClusterInstance:

<InterpolatedCodeBlock
  code={`kubectl edit virtualclusterinstance [[VAR:VCLUSTER NAME:my-vcluster]] -n [[VAR:NAMESPACE:vcluster-my-team]]`}
  language="bash"
/>

<br />

Add or update the following configuration:

<InterpolatedCodeBlock
  code={`controlPlane:
  statefulSet:
    scheduling:
      podManagementPolicy: Parallel`}
  language="yaml"
/>

<br />

If using Helm, update your `values.yaml` and run:

<InterpolatedCodeBlock
  code={`helm upgrade [[VAR:VCLUSTER NAME:my-vcluster]] vcluster \
  --repo https://charts.loft.sh \
  --namespace [[VAR:NAMESPACE:vcluster-my-team]] \
  --reuse-values \
  -f values.yaml`}
  language="bash"
/>

<br />

The StatefulSet is recreated with `Parallel` policy and pods pick up the existing PVCs.
</Step>

<Step title="Delete the failed pod and PVC">
Now follow the same procedure as for `Parallel` mode:

<InterpolatedCodeBlock
  code={`kubectl delete pod [[VAR:VCLUSTER NAME:my-vcluster]]-0 -n [[VAR:NAMESPACE:vcluster-my-team]]
kubectl delete pvc [[VAR:PVC PREFIX:data]]-[[VAR:VCLUSTER NAME:my-vcluster]]-0 -n [[VAR:NAMESPACE:vcluster-my-team]]`}
  language="bash"
/>

<br />

The pod restarts with a new empty PVC and automatic recovery adds it back to the cluster after 1-3 pod restarts.
</Step>
</Flow>

</TabItem>
</Tabs>

:::warning
Never clone PVCs from other replicas. Cloning PVCs causes etcd member ID conflicts and results in data loss.
:::

</TabItem>
</Tabs>

### Complete data loss recovery

:::warning
This recovery method results in data loss up to the last backup point. Only proceed if you have verified that all etcd replicas are corrupted and no working replicas remain.
:::

When the majority of etcd member replicas become corrupted or deleted simultaneously, the entire cluster requires recovery from backup.

<Flow>
<Step title="Assess the damage" danger>
Verify all PVCs are corrupted or inaccessible:

<InterpolatedCodeBlock
  code={`kubectl get pvc -l [[VAR:VCLUSTER LABEL:app=vcluster]] -n [[VAR:NAMESPACE:vcluster-my-team]]`}
  language="bash"
/>

<br />

<InterpolatedCodeBlock
  code={`kubectl describe pvc [[VAR:PVC PREFIX:data]]-[[VAR:VCLUSTER NAME:my-vcluster]]-0 [[VAR:PVC PREFIX:data]]-[[VAR:VCLUSTER NAME:my-vcluster]]-1 [[VAR:PVC PREFIX:data]]-[[VAR:VCLUSTER NAME:my-vcluster]]-2 -n [[VAR:NAMESPACE:vcluster-my-team]]`}
  language="bash"
/>
</Step>

<Step title="Scale down to zero replicas">
Stop all vCluster instances before beginning recovery:

<InterpolatedCodeBlock
  code={`kubectl scale statefulset [[VAR:VCLUSTER NAME:my-vcluster]] --replicas=0 -n [[VAR:NAMESPACE:vcluster-my-team]]`}
  language="bash"
/>
</Step>

<Step title="Delete corrupted PVCs">
Delete all corrupted PVCs:

<InterpolatedCodeBlock
  code={`kubectl delete pvc [[VAR:PVC PREFIX:data]]-[[VAR:VCLUSTER NAME:my-vcluster]]-0 [[VAR:PVC PREFIX:data]]-[[VAR:VCLUSTER NAME:my-vcluster]]-1 [[VAR:PVC PREFIX:data]]-[[VAR:VCLUSTER NAME:my-vcluster]]-2 -n [[VAR:NAMESPACE:vcluster-my-team]]`}
  language="bash"
/>
</Step>

<Step title="Restore from backup or snapshot">
Follow a backup restoration procedure. This typically involves restoring PVCs from your backup solution (Velero, CSI snapshots, or similar tools).

<br />

Restore from snapshot:

<InterpolatedCodeBlock
  code={`kubectl apply -f [[VAR:RESTORE FILE:backup-restore.yaml]]`}
  language="bash"
/>
</Step>

<Step title="Start vCluster with restored data">
Scale up to a single replica to verify the restoration:

<InterpolatedCodeBlock
  code={`kubectl scale statefulset [[VAR:VCLUSTER NAME:my-vcluster]] --replicas=1 -n [[VAR:NAMESPACE:vcluster-my-team]]`}
  language="bash"
/>

<br />

Monitor logs and verify the cluster starts successfully:

<InterpolatedCodeBlock
  code={`kubectl logs -f [[VAR:VCLUSTER NAME:my-vcluster]]-0 -n [[VAR:NAMESPACE:vcluster-my-team]]`}
  language="bash"
/>

<br />

After it's verified, scale to the desired number of replicas.
</Step>
</Flow>

## Config reference

<ConfigReference/>
