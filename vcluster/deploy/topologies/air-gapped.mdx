---
title: Deploy vCluster in an air-gapped environment
sidebar_label: Air-gapped
sidebar_position: 5
description: Learn how to install vCluster in an air-gapped Kubernetes cluster.
sidebar_class_name: pro
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Flow, { Step } from "@site/src/components/Flow";
import BasePrerequisites from '../../../platform/_partials/install/base-prerequisites.mdx';

import FipsConfig from '../../_partials/deploy/fips-config.mdx';

import LicenseKey from '../../_partials/deploy/license_key.mdx';
import ProAdmonition from '../../_partials/admonitions/pro-admonition.mdx';


# Deploy vCluster in an air-gapped environment


<ProAdmonition/>

This document details the steps to install vCluster into
a Kubernetes cluster that doesn't have access to the internet. 

## Pre-requisites

- OCI-compliant Private Registry - A private registry that can be access by the Kubernetes host cluster as well as a separate machine that has access to the internet. 
- An offline license key for vCluster - A license key provided by LoftLabs is required to be able to enable using an airgapped cluster. 
    :::info
    <LicenseKey />
    :::


## Overview 

When deploying vCluster, there are two artifacts that are typically accessed using an internet connection. Therefore, to complete an air-gapped deployment, these artifacts need to be accessible by the Kubernetes host cluster through a private registry.

- vCluster Helm chart - This Helm chart is typically accessed through the LoftLabs charts repository. 
- Images used in the vCluster Helm Chart - These images are typically accessed through different container registries. 

:::warning
When using virtual clusters in air-gapped environments, the
`config.experimental.deploy.vcluster.helm` [configuration setting](/docs/vcluster/configure/vcluster-yaml/#experimental-deploy-vcluster) does not work with external Helm repositories since they cannot be accessed. This means custom Helm charts from repositories like `charts.bitnami.com` cannot be used for virtual cluster deployments.
:::


## Populate images to private registry

You need to push the required images to your OCI-compliant private registry. 
Each vCluster release has multiple release assets that are available to make uploading the images to the private registry.

* `images.txt` - The required images to run vCluster, which assumes using the default Kubernetes version.
* `images-optional.txt` - An optional set of images to run vCluster using a different Kubernetes version.
* `download-images.sh` - A bash script that quickly iterates over all the images files to pull them and package them into a tarball to a machine that has internet access. 
* `push-images.sh` - A bash script that takes the tarball generated from the download script to push them to your private registry. 

### Pre-requisites 

- Access to the internet
- Ability to push to your OCI-compliant private registry
- Logged in to GitHub Container Registry
- `wget` installed
- `docker` installed 

### Pull and push images 

<Flow id="offline-images">
<Step>

Set environment variables for the version of vCluster that you want to deploy and the private registry. 

      ```bash title="Export environment variables"
      export VCLUSTER_VERSION=0.25.0 # Replace with the desired version
      export REGISTRY=ecr.io/myteam # This should be a prefix; do not include any image paths
      ```
</Step>
  <Step>

Download the assets from the vCluster Github release and make the scripts executable.

:::tip
The 
`images.txt` contains all distributions for the default Kubernetes version. You can edit the
file and remove the images for the unused distributions. 
:::

```bash title="Download assets and prepare scripts"
wget https://github.com/loft-sh/vcluster/releases/download/v"${VCLUSTER_VERSION}"/images.txt
wget https://github.com/loft-sh/vcluster/releases/download/v"${VCLUSTER_VERSION}"/download-images.sh
wget https://github.com/loft-sh/vcluster/releases/download/v"${VCLUSTER_VERSION}"/push-images.sh

chmod +x ./download-images.sh
chmod +x ./push-images.sh
```

  </Step>
  <Step>

Run `download-images.sh` to pull all images and create a tarball of the images:

```bash title="Download and package images"
./download-images.sh --image-list images.txt
```

:::tip
Review the output to confirm all images were pulled successfully and packaged in the tarball. 
:::

  </Step>
  <Step>

Run `push-images.sh` to push all the images to your private registry:

```bash title="Push images to private registry"

./push-images.sh --registry ${REGISTRY} 
```

    </Step>
    <Step>
    **Optional:** If you plan to use a different Kubernetes version, you can download the `images-optional.txt` to pull and push those specific images into your private registry. 
    
    :::tip
    The 
`images.txt` contains multiple Kubernets versions and distributions. You can edit the
file and remove the images for the unused versions and distributions. 
    :::

    ```bash title "Pull, package and push all optional images"
    wget https://github.com/loft-sh/vcluster/releases/download/v${VCLUSTER_VERSION}/images-optional.txt
    ./download-images.sh --image-list images-optional.txt
    ./push-images.sh --registry ${REGISTRY}
    ```
    
  </Step>
</Flow>

## Populate vCluster Helm chart to private registry

You need to push the vCluster Helm chart to your OCI-compliant private registry. 

### Pre-requisites 

- Access to the internet
- Ability to push to your OCI-compliant private registry
- `curl` installed
- `helm` installed: Helm v3.10+

### Download and push the vCluster Helm chart

<Flow id="offline-helm-chart">
<Step>

**Optional**: If you didn't set the environment variables when downloading the images, set them now. 

      ```bash title="Export environment variables"
      export VCLUSTER_VERSION=0.25.0 # Replace with the desired version
      export REGISTRY=ecr.io/myteam # This should be a prefix; do not include any image paths
      ```
</Step>
<Step>

```bash title="Download the vCluster Helm chart
curl -O https://charts.loft.sh/charts/vcluster-"${VCLUSTER_VERSION}".tgz
```
</Step>

<Step>

```bash title="Push your chart to your private registry"
helm chart save ./vcluster-${VCLUSTER_VERSION}.tgz ${REGISTRY}/vcluster:v${VCLUSTER_VERSION}
helm chart push ${REGISTRY}/vcluster:v${VCLUSTER_VERSION}
```
</Step>
</Flow>

## Configure vCluster

The `vcluster.yaml` file holds all of your vCluster configuration options. 

### Use a private registry without credentials

```yaml title="Setting the Image Registry"
controlPlane:
 advanced:
   defaultImageRegistry: ecr.io/myteam # Replace with your private registry
```

### Use an authenticated private registry

If your private registry requires authentication, you need to create a secret in the namespace on the host cluster of where the vCluster will be deployed in. 
You need to set an image pull secret to be used by the vCluster control plane for images required to deploy vCluster. Optionally, you can also set the same image pull secret so that any image
deployed in the vCluster referencing the private registry would also use the same credentials. 

```yaml title="Image Pull Secrets configuration"
controlPlane:
  advanced:
    defaultImageRegistry: ecr.io/myteam # Replace with your private image registry
    serviceAccount:
      imagePullSecrets: # Uses credentials for the vCluster control plane
        - name: registry-credentials-secret-name # Replace with the name of the secret deployed on the host cluster that will be where your vCluster is deployed in
    workloadServiceAccount: # Uses credentials for any workloads created in the vCluster 
      imagePullSecrets:
        - name: registry-credentials-secret-name # Replace with the name of the secret deployed on the host cluster that will be where your vCluster is deployed in
```

### Use a non-default Kubernetes Version

If you've downloaded to use a different Kubernetes version using the `images-optional.txt`, then you'll need to configure vCluster to use that version. 

```yaml title="Specific Kubernetes Version configuration"
controlPlane:
  distro:
    k8s:
      image:
        tag: v1.31.1 # Replace with the Kubernetes version that you have chosen
```

### Replace the alpine image 

If you are using `sync.toHost.pods.rewriteHosts` feature, then you need to directly replace the full path of the alpine image to use the private registry as the `defaultImageRegistry` does not apply to this image.

```yaml title="Replacing the alpine image"
sync:
  toHost:
    pods:
      rewriteHosts:
        initContainer:
          image: your-registry/library/alpine:3.20
```

### Reference the license key

The `apiKey` is required to reference the license key to enable your Kubernetes cluster. 

:::note
Although the config appears similar to when connecting a virtual cluster to the platform, the `apiKey` secret's actual value is your air-gapped license key.
:::

```bash title="API Key configuration to activate enterprise features"
external:
  platform:
    apiKey:
      # The air-gapped license key provided by Loft has to be the data
      # under the first key (name does not matter) of the secret.
      secretName:
      # Namespace to search for the secret. If undefined,
      # it searches the namespace that the vCluster is deployed in.
      # If different than the namespace of the vCluster deployment,
      # then vCluster needs access to that namespace.
      namespace:
      # Default enabled to create the necessary RBAC roles
      # and role bindings in order to find the secret
      createRBAC: true
```


##  Install vCluster

### Pre-requisites 

- Host cluster needs to be able to pull from the private registry
<BasePrerequisites />

<Flow>
  <Step>
  On the host cluster, create the namespace for the vCluster, where the secrets and vCluster control plane pod will be deployed into. 

  ```bash title="Create vCluster namespace"
  export VCLUSTER_NAMESPACE=vcluster-my-vcluster 
  kubectl create namespace ${VCLUSTER_NAMESPACE}
  ```

  </Step>
  <Step>

  Create the secret to validate the license. 

Create a Kubernetes secret from the license key provided by LoftLabs in the namespace for the vCluster.

:::tip
License secret is already `base64` encoded.
:::

```bash title="Create Kubernetes secret for License Key"
# Set the license key as an environment variable (already base64 encoded)
export VCLUSTER_LICENSE_KEY="YOUR_BASE64_ENCODED_LICENSE_KEY_HERE"

# Create secret
kubectl create -f - <<EOF
apiVersion: v1
kind: Secret
metadata:
  name: vcluster-platform-license-key
  namespace: ${VCLUSTER_NAMESPACE}
type: Opaque
data:
  license: ${VCLUSTER_LICENSE_KEY}
EOF
```
  </Step>
  <Step>
**Optional** Create the secret to authenticate to the private registry.

Create a Kubernetes secret with the login credentials for your private registry in the namespace for the vCluster.

```bash title="Create Kubernetes secret for login credentials"
kubectl create -f - <<EOF
apiVersion: v1
kind: Secret
metadata:
  name: registry-credentials-secret-name
  namespace: ${VCLUSTER_NAMESPACE}
type: Opaque
data:
  # Credentials based on your private registry
EOF
```

  </Step>

  <Step>
Review your `vcluster.yaml` file.

Use the `vcluster.yaml` file with the necessary
configuration for your air-gapped vCluster installation. 

```yaml title="vcluster.yaml configuration"
controlPlane:
  advanced:
    defaultImageRegistry: ecr.io/myteam # Replace with your private image registry
    serviceAccount:
      imagePullSecrets: 
        - name: registry-credentials-secret-name # Replace with the name of the registry credentials secret
    workloadServiceAccount: 
      imagePullSecrets:
        - name: registry-credentials-secret-name # Replace with the name of the registry credentials secret
  
external:
  platform:
    apiKey:
      secretName: vcluster-platform-license-key
```

  </Step>
<Step>
Pull the vCluster Helm chart from the private registry.

```bash title="Pull the Helm chart"
export VCLUSTER_VERSION=0.25.0 # Replace with the chart version that was pushed into your private registry
export REGISTRY=myecr.io/team # Replace with the private registry

## Login to helm registry if you haven't
helm registry login ${REGISTRY} \
  --username myuser \
  --password mypassword

helm pull oci://${REGISTRY}/vcluster:v${VCLUSTER_VERSION}
```
</Step>
<Step>

Install vCluster into the namespace where you installed the secrets.

```bash title="Install vCluster with Helm"
export VCLUSTER_NAME="my-vcluster" # Replace with what you want to name your vCluster

helm upgrade --install "${VCLUSTER_NAME}" oci://${REGISTRY}/vcluster:v${VCLUSTER_VERSION} \
  --version ${VCLUSTER_VERSION} \
  --values vcluster.yaml \
  --namespace ${VCLUSTER_NAMESPACE} \
```

</Step>

</Flow>
## Air-gapped vCluster with FIPS images

To run vCluster in a FIPS compliant environment, the FIPS images need to be pushed into your private registry. The following images need to be pushed into your registry. The tag is the Kubernetes version that are available in the `images.txt` and `optional-images.txt` files. 

- ghcr.io/loft-sh/kubernetes-fips
- ghcr.io/loft-sh/etcd-fips
- ghcr.io/loft-sh/kine-fips
- ghcr.io/loft-sh/helm-fips


:::info
Refer to the [FIPS configuration guide](/vcluster/deploy/security/fips) for more details.
:::

The same instructions apply above, with the only difference being that you are referencing the FIPS compliant images. 

The following is an example `vcluster.yaml` configuration with the FIPS compliant images. 

<details>
  <summary>FIPS configuration</summary>
  <FipsConfig />
</details>
