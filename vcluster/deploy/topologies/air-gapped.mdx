---
title: Deploy vCluster in an air-gapped environment
sidebar_label: Air-gapped
sidebar_position: 5
description: Learn how to install vCluster in an air-gapped Kubernetes cluster.
sidebar_class_name: pro
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Flow, { Step } from "@site/src/components/Flow";
import BasePrerequisites from '../../../platform/_partials/install/base-prerequisites.mdx';

import FipsConfig from '../../_partials/deploy/fips-config.mdx';

import LicenseKey from '../../_partials/deploy/license_key.mdx';
import ProAdmonition from '../../_partials/admonitions/pro-admonition.mdx';


# Deploy vCluster in an air-gapped environment


<ProAdmonition/>

This document details the steps to install vCluster into
a Kubernetes cluster that doesn't have access to the internet. 

## Overview of artifacts to download

When deploying vCluster, there are two artifacts that are typically accessed using an internet connection. Therefore, in order to complete an air-gapped deployment, these artifacts will need to be made locally accessible to the user deploying vCluster:

- vCluster Helm chart - This Helm chart is typically accessed through the LoftLabs charts repository. 
- Container images used in the vCluster Helm Chart - These images are typically accessed through different container registries. 

:::warning
When using virtual clusters in air-gapped environments, the
`config.experimental.deploy.vcluster.helm` [configuration setting](/docs/vcluster/configure/vcluster-yaml/#experimental-deploy-vcluster) does not work with external Helm repositories since they cannot be accessed. This means custom Helm charts from repositories like `charts.bitnami.com` cannot be used for virtual cluster deployments.
:::

## General Pre-requisites

- Private OCI-compliant Registry 
- An offline license key for vCluster, provided by LoftLabs
    :::info
    <LicenseKey />
    :::

## Populate images to private registry

For Kubernetes clusters that don't have access to the internet, you need to push the required images to your private registry. 
Each vCluster release, has multiple release assets that are available to make this process easier.

* `images.txt` - The required images to run vCluster, which assumes using the default Kubernetes version.
* `images-optional.txt` - The optional set of images to run vCluster using a different Kubernetes version.
* `download-images.sh` - A bash script that quickly iterates over all the images files to pull them and packaged them into a tarball to your local machine. 
* `push-images.sh` - A bash script that takes the tarball generated from the download script to push them to your private image registry. 

Follow these instructions to download all vCluster images and import them to your private registry:

### Pre-requisites 

These need to be available on the machine that has internet access that will push and pull images to the private registry:

- Ability to push to your private registry
- Logged in to GitHub Container Registry
- `wget` installed
- `docker` installed 

### Push images 

<Flow id="offline-images">
<Step>

Set environment variables for the version of vCluster that you want to deploy and the image registry that the target cluster can access. 

      ```bash title="Export environment variables"
      export VCLUSTER_VERSION=0.25.0 # Replace with the desired version
      export REGISTRY=ecr.io/myteam # This should be a prefix; do not include any image paths
      ```
</Step>
  <Step>

Download the required assets from the Github release and make the scripts executable.

:::tip
The 
`images.txt` contains all distros for the default Kubernetes version. You can edit the
file and remove the distro images that you do not need.
:::

```bash title="Download assets and prepare scripts"
wget https://github.com/loft-sh/vcluster/releases/download/v"${VCLUSTER_VERSION}"/images.txt
wget https://github.com/loft-sh/vcluster/releases/download/v"${VCLUSTER_VERSION}"/download-images.sh
wget https://github.com/loft-sh/vcluster/releases/download/v"${VCLUSTER_VERSION}"/push-images.sh

chmod +x ./download-images.sh
chmod +x ./push-images.sh
```

  </Step>
  <Step>

Run `download-images.sh` to pull all images locally and create a tarball of all of the images:

```bash title="Download images"
./download-images.sh --image-list images.txt
```

:::warning
Review the output to confirm all images were pulled succesfully and packaged in the tarball. 
:::

  </Step>
  <Step>

Run `push-images.sh` to push all the images to your private image registry:

```bash title="Push images to private registry"

./push-images.sh --registry ${REGISTRY} 
```

:::info
vCluster prepends the image registry to all images used by vCluster, such as syncer and Kubernetes. For example, `registry.k8s.io/kube-apiserver:v1.30.2` becomes `my-private-registry:5000/vcluster/kube-apiserver:v1.30.2`.
:::

    </Step>
    <Step>
    **Optional:** If you plan to use a different Kubernetes version, you can download the `images-optional.txt` to pull and push those images into your private image registry. 
    
    :::tip
    You can remove images from `images-optional.txt` that you don't need as multiple Kubernetes versions and all available Kubernetes distributions are in the file.
    :::

    ```bash title "Pull and push all optional images"
    wget https://github.com/loft-sh/vcluster/releases/download/v${VCLUSTER_VERSION}/images-optional.txt
    ./download-images.sh --image-list images-optional.txt
    ./push-images.sh --registry ${REGISTRY}
    ```

    
  </Step>
</Flow>

## Populate vCluster Helm Chart to private registry

### Pre-requisites 

These need to be available on a machine that has internet access that will push and pull the helm chart to the private registry:

- Ability to push to your OCI-compatible private image regsitry
- `curl` installed
- `helm` installed: Helm v3.10+


### Push vCluster Helm chart

<Flow id="offline-helm-chart">
<Step>

```bash title="Download the vCluster Helm chart"
export VCLUSTER_VERSION="0.25.0"  # Replace with the desired version
curl -O https://charts.loft.sh/charts/vcluster-"${VCLUSTER_VERSION}".tgz
```
</Step>

<Step>

```bash title="Push your chart to your private registry"
export REGISTRY=ecr.io/myteam # This should be a prefix; do not include any image paths

helm chart save ./vcluster-${VCLUSTER_VERSION}.tgz ${REGISTRY}/vcluster:v${VCLUSTER_VERSION}
helm chart push ${REGISTRY}/vcluster:v${VCLUSTER_VERSION}
```
</Step>
</Flow>

## Configure vCluster

The `vcluster.yaml` file holds all of your vCluster configuration options. 

### Use an image registry without credentials

```yaml title="Setting the Image Registry"
controlPlane:
 advanced:
   defaultImageRegistry: ecr.io/myteam # Replace with your private image registry
```

### Use an authenticated private registry

If your private registry requires authentication, you can create a secret in the namespace on the host cluster of where the vCluster will be deployed in. 
In the `vcluster.yaml`, you set an image pull secret to be used by the vCluster control plane `ServiceAccount` to pull all your images from your authenticated registry.

```yaml title="Image Pull Secrets configuration"
controlPlane:
  advanced:
    defaultImageRegistry: ecr.io/myteam # Replace with your private image registry
    serviceAccount:
      imagePullSecrets: # Use credentials for the vCluster control plane
        - name: registry-credentials-secret-name # Replace with the name of the secret deployed on the host cluster that will be where your vCluster is deployed in
    workloadServiceAccount: # Uses credentials for any workloads created in the vCluster
      imagePullSecrets:
        - name: registry-credentials-secret-name # Replace with the name of the secret deployed on the host cluster that will be where your vCluster is deployed in
```

### Use a non-default Kubernetes Version

If you've downloaded to use a different Kubernetes version using the `images-optional.txt`, then you'll need to configure vCluster to use that version. 

```yaml title="Specific Kubernetes Version configuration"
controlPlane:
  distro:
    k8s:
      version: v1.31.1 # Replace with the Kubernetes version that you have chosen
```

### Using the Alpine image 

If you are using `sync.toHost.pods.rewriteHosts` feature, then you will need to directly replace the full path of the alpine image to use the private registry as the `defaultImageRegistry` does not apply to this image.

```yaml title="Replacing the alpine image"
sync:
  toHost:
    pods:
      rewriteHosts:
        initContainer:
          image: your-registry/library/alpine:3.20
```

### Activate enterprise features

The `apiKey` provides a way to activate enterprise features in vCluster without vCluster Platform. 

:::note
Although the config appears similar to when using the platform, the `apiKey` secret's actual value is your air-gapped license key.
:::

```bash title="API Key configuration to activate enterprise features"
external:
  platform:
    apiKey:
      # The air-gapped license key provided by Loft has to be the data
      # under the first key (name does not matter) of the secret.
      secretName:
      # Namespace to search for the secret. If undefined,
      # it searches the namespace that the vCluster is deployed in.
      # If different than the namespace of the vCluster deployment,
      # then vCluster needs access to that namespace.
      namespace:
      # Default enabled to create the necessary RBAC roles
      # and role bindings in order to find the secret
      createRBAC: true
```


##  Install vCluster

### Pre-Requisites 
- Ability to pull from your private registry
<BasePrerequisites />

<Flow>
  <Step>
  On the host cluster, create the namespace for the vCluster.

  ```bash title="Create vCluster namespace"
  export VCLUSTER_NAMESPACE=vcluster-my-vcluster 
  kubectl create namespace ${VCLUSTER_NAMESPACE}
  ```

  </Step>
  <Step>

  Create the secret to validate the license. 

Create a Kubernetes secret from the License Key provided by LoftLabs in the namespace for the vCluster.

:::tip
License secret is already `base64` encoded.
:::

```bash title="Create Kubernetes secret for License Key"
# Set the license key as an environment variable (already base64 encoded)
export VCLUSTER_LICENSE_KEY="YOUR_BASE64_ENCODED_LICENSE_KEY_HERE"

# Create secret
kubectl create -f - <<EOF
apiVersion: v1
kind: Secret
metadata:
  name: vcluster-platform-license-key
  namespace: ${VCLUSTER_NAMESPACE}
type: Opaque
data:
  license: ${VCLUSTER_LICENSE_KEY}
EOF
```
  </Step>
  <Step>
**Optional** Create the secret to authenticate to the private registry.

Create a Kubernetes secret with the login credentials for your private registry in the namespace for the vCluster.

```bash title="Create Kubernetes secret for login credentials"
kubectl create -f - <<EOF
apiVersion: v1
kind: Secret
metadata:
  name: registry-credentials-secret-name
  namespace: ${VCLUSTER_NAMESPACE}
type: Opaque
data:
  # Credentials based on your private registry
EOF
```

  </Step>

  <Step>
Review your `vcluster.yaml` file.

Use the `vcluster.yaml` file with the necessary
configuration for your air-gapped vCluster installation. 

```yaml title="vcluster.yaml configuration"
controlPlane:
  advanced:
    defaultImageRegistry: my-private-registry:5000/vcluster/
    defaultImageRegistry: ecr.io/myteam # Replace with your private image registry
    serviceAccount:
      imagePullSecrets: 
        - name: registry-credentials-secret-name # Replace with the name of the registry credentials secret
    workloadServiceAccount: 
      imagePullSecrets:
        - name: registry-credentials-secret-name # Replace with the name of the registry credentials secret
  
external:
  platform:
    apiKey:
      secretName: vcluster-platform-license-key
```

  </Step>
<Step>
Pull the vCluster Helm chart from the private registry.

```bash title="Pull the Helm chart"
export VCLUSTER_VERSION=0.25.0 # Replace with the chart version that was pushed into your private registry
export REGISTRY=myecr.io # Replace with the private registry

## Login to helm registry if you haven't
helm registry login ${REGISTRY} \
  --username myuser \
  --password mypassword

helm pull oci://${REGISTRY}/vcluster:v${VCLUSTER_VERSION}
```
</Step>
<Step>

Install the locally pulled Helm chart into the `namespace` where you installed the secrets.

```bash title="Install vCluster with Helm"
export VCLUSTER_NAME="my-vcluster" # Replace with what you want to name your vCluster

helm upgrade --install "${VCLUSTER_NAME}" vcluster:v${VCLUSTER_VERSION} \
  --version ${VCLUSTER_VERSION} \
  --values vcluster.yaml \
  --namespace ${VCLUSTER_NAMESPACE} \
```

</Step>

</Flow>
## Air-gapped vCluster Pro with FIPS images

To run vCluster in a FIPS compliant environment, the `vcluster.yaml` needs to be configured to use the Loft GitHub Container Registry with the FIPS compliant images for the syncer (vCluster control plane `StatefulSet`) and the Kubernetes distro images and configured to use the vCluster Pro embedded CoreDNS.

:::info
Refer to the [FIPS configuration guide](/vcluster/deploy/security/fips) for more details.
:::

The following is an example `vcluster.yaml` configuration of air-gapped vCluster Pro with FIPS compliant images and assumes you have created a `Secret` named `vcluster-platform-api-key` with the air-gapped license key provided by Loft in the same `Namespace` where you are deploying the vCluster instance

<details>
  <summary>FIPS configuration</summary>
  <FipsConfig />
</details>
