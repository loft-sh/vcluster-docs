import Highlight from "@site/src/components/Highlight/Highlight";

import Flow, { Step } from "@site/src/components/Flow";
import NavStep from "@site/src/components/NavStep";
import Field from "@site/src/components/Field";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

import IstioPartial from "../../_partials/config/integrations/istio.mdx";
import BasePrerequisites from "@site/docs/_partials/base-prerequisites.mdx";
import PageVariables from '@site/src/components/PageVariables';
import InterpolatedCodeBlock from "@site/src/components/InterpolatedCodeBlock";
import Deploy from "../../_partials/deploy/deploy.mdx";
import ProAdmonition from "../../_partials/admonitions/pro-admonition.mdx";
import IstioSupportMatrix from "@site/docs/_partials/istio-support-matrix.mdx";

<ProAdmonition />

# Istio integration

This guide shows how to set up Istio integration with your virtual cluster.
This enables you to use one Istio installation from the host cluster instead of installing Istio in each virtual cluster.

You can include your virtual workloads in the mesh by setting `istio.io/dataplane-mode=ambient` label on the virtual Namespaces or Pods.
You can exclude your virtual workloads from the mesh by setting `istio.io/dataplane-mode=none` label either on the Namespace or on the Pod.

<IstioSupportMatrix />

### Prerequisites

<BasePrerequisites />

- `istio` operator installed on your host cluster in ambient mode with DNS Capture disabled

:::warning
To disable DNS capture, set `values.cni.ambient.dnsCapture: false` in your Istio configuration.
This integration works only with Istio in Ambient mode. Sidecar mode is not supported.
:::

## Enable the integration

Enable the Istio integration in your virtual cluster configuration:

```yaml title="Enable istio integration"
integrations:
  istio:
    enabled: true
```

This configuration:

- Enables the integration.
- Installs Resource Definitions for `DestinationRules`, `Gateways` and `VirtualServices` into the virtual cluster.
- Exports `DestinationRules`, `Gateways` and `VirtualServices` from the virtual cluster to the host (and re-writes) service references to the services translated names in the host.
- Adds `istio.io/dataplane-mode` label to the synced Pods based on the value of this label set in the virtual namespace.

:::warning
Only `DestinationRules`, `Gateways`, and `VirtualServices` from `networking.istio.io/v1` API Version are synced to the host clusters. Other kinds are not yet supported.
:::

<!--vale off-->
## Route request based on the version label of the app
<Flow id="istio-example">

  ### Set up cluster contexts
  <Step>
  Setting up the host and virtual cluster contexts makes it easier to switch
  between them. You can adjust the values below according to your setup. The 
  commands in the following steps will be automatically updated to follow your 
  configuration. For the GatewayAPI version, you should set it according to 
  your Istio version / GatewayAPI version matrix above.

  <PageVariables HOST_CONTEXT="your-host-context" VCLUSTER_CONTEXT="vcluster-ctx" VCLUSTER_HOST_NAMESPACE="vcluster" GATEWAY_API_VERSION="v1.2.1" TEST_NAMESPACE_NAME="test"/>

  :::tip
  You can find your contexts by running `kubectl config get-contexts`
  :::
  </Step>

  ### Create waypoint proxy in the host
  <Step>
    In this tutorial, you set Kubernetes service name as a host in the VirtualService `spec.hosts`.
    To make it work, you need a Waypoint proxy in the virtual cluster's host namespace.
    In many cases it is optional however. Refer to Istio documentation for more information on Waypoint proxies.
    Install Gateway CRD first in the host:

    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:HOST_CONTEXT]]" get crd gateways.gateway.networking.k8s.io &> /dev/null || \\
    kubectl --context="[[GLOBAL:HOST_CONTEXT]]" apply -f "https://github.com/kubernetes-sigs/gateway-api/releases/download/[[GLOBAL:GATEWAY_API_VERSION]]/standard-install.yaml"`}
      language="bash"
      title="Install Gateway CRD"
    />


    this is a Gateway for Waypoint you need:
    ```yaml title="waypoint-gateway.yaml"
    apiVersion: gateway.networking.k8s.io/v1
    kind: Gateway
    metadata:
      name: waypoint
      labels:
        istio.io/waypoint-for: service
    spec:
      gatewayClassName: istio-waypoint
      listeners:
      - name: mesh
        port: 15008
        protocol: HBONE
    ```

    create it in the host cluster:

    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:HOST_CONTEXT]]" create -f waypoint-gateway.yaml --namespace="[[GLOBAL:VCLUSTER_HOST_NAMESPACE]]"`}
      language="bash"
      title="Create Waypoint Gateway"
    />

  </Step>

  ### Create virtual namespace with ambient mode enabled
  <Step>
    First, you need to create a test namespace:

    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:VCLUSTER_CONTEXT]]" create namespace [[GLOBAL:TEST_NAMESPACE_NAME]]`}
      language="bash"
      title="Create a test namespace"
    />

    and label it with `istio.io/dataplane-mode: ambient`:
    
    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:VCLUSTER_CONTEXT]]" label namespace [[GLOBAL:TEST_NAMESPACE_NAME]] istio.io/dataplane-mode=ambient`}
      language="bash"
      title="Label the test namespace"
    />

  </Step>

  ### Create two versions of your app

  <Step>
    Next, you create 3 deployments: two of them are nginx server and the third one is to curl the other two.

    Create NGINX deployments that respond with different response bodies based on the contents of their respective ConfigMaps:

<InterpolatedCodeBlock
code={`apiVersion: v1
  kind: ConfigMap
  metadata:
    name: nginx-configmap-v1
    namespace: [[GLOBAL:TEST_NAMESPACE_NAME]]
  data:
    index.html: |
      <!DOCTYPE html>
      <html>
      <head>
        <title>Welcome to nginx v1!</title>
      </head>
      <body>
      <h1>Hello from Nginx Version 1!</h1>
      </body>
      </html>`}
  language="yaml"
  title="configmap1.yaml"
/>

<InterpolatedCodeBlock
code={`apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx-deployment-v1
    namespace: [[GLOBAL:TEST_NAMESPACE_NAME]]
    labels:
      app: nginx
      version: v1
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: nginx
        version: v1
    template:
      metadata:
        labels:
          app: nginx
          version: v1
      spec:
        containers:
          - name: nginx
            image: nginx:latest
            ports:
              - containerPort: 80
            volumeMounts:
              - name: nginx-index-v1
                mountPath: /usr/share/nginx/html/index.html
                subPath: index.html
        volumes:
          - name: nginx-index-v1
            configMap:
              name: nginx-configmap-v1`}
  language="yaml"
  title="deployment1.yaml"
/>


    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:VCLUSTER_CONTEXT]]" create -f configmap1.yaml --namespace [[GLOBAL:TEST_NAMESPACE_NAME]]`}
      language="bash"
      title="Create v1 config map"
    />

    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:VCLUSTER_CONTEXT]]" create -f deployment1.yaml --namespace [[GLOBAL:TEST_NAMESPACE_NAME]]`}
      language="bash"
      title="Create v1 deployment"
    />

    make sure that this nginx app is up and running:

    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:VCLUSTER_CONTEXT]]" wait --for=condition=ready pod -l app=nginx --namespace [[GLOBAL:TEST_NAMESPACE_NAME]] --timeout=300s`}
      language="bash"
      title="Wait for v1 pods"
    />

    Create an additional NGINX deployment configured to serve a different response body, using a separate ConfigMap:

<InterpolatedCodeBlock
  code={`apiVersion: v1
  kind: ConfigMap
  metadata:
    name: nginx-configmap-v2
    namespace: [[GLOBAL:TEST_NAMESPACE_NAME]]
  data:
    index.html: |
      <!DOCTYPE html>
      <html>
      <head>
        <title>Welcome to nginx v2!</title>
      </head>
      <body>
        <h1>Hello from Nginx Version 2!</h1>
      </body>
      </html>`}
  language="yaml"
  title="configmap2.yaml"
/>


<InterpolatedCodeBlock
  code={`apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: nginx-deployment-v2
    namespace: [[GLOBAL:TEST_NAMESPACE_NAME]]
    labels:
      app: nginx
      version: v2
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: nginx
        version: v2
    template:
      metadata:
        labels:
          app: nginx
          version: v2
      spec:
        containers:
          - name: nginx
            image: nginx:latest
            ports:
              - containerPort: 80
            volumeMounts:
              - name: nginx-index-v2
                mountPath: /usr/share/nginx/html/index.html
                subPath: index.html
        volumes:
          - name: nginx-index-v2
            configMap:
              name: nginx-configmap-v2`}
  language="yaml"
  title="deployment2.yaml"
/>


    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:VCLUSTER_CONTEXT]]" create -f configmap2.yaml --namespace [[GLOBAL:TEST_NAMESPACE_NAME]]`}
      language="bash"
      title="Create v2 config map"
    />

    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:VCLUSTER_CONTEXT]]" create -f deployment2.yaml --namespace [[GLOBAL:TEST_NAMESPACE_NAME]]`}
      language="bash"
      title="Create v1 deployment"
    />

    To ensure your NGINX application is up and running in your Kubernetes cluster, use the following command:

    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:VCLUSTER_CONTEXT]]" wait --for=condition=ready pod -l app=nginx --namespace [[GLOBAL:TEST_NAMESPACE_NAME]] --timeout=300s`}
      language="bash"
      title="Wait for v2 pods"
    />

    Create a Service that targets Pods from both Deployments by using a shared label:

<InterpolatedCodeBlock
  code={`apiVersion: v1
  kind: Service
  metadata:
    name: nginx-service
    namespace: [[GLOBAL:TEST_NAMESPACE_NAME]]
    labels:
      app: nginx
      istio.io/use-waypoint: "waypoint"
  spec:
    ports:
      - port: 80
        targetPort: 80
    selector:
      app: nginx`}
  language="yaml"
  title="service.yaml"
/>

    The istio.io/use-waypoint: waypoint label directs Istio to route traffic for the labeled resource through the waypoint proxy within the same namespace. This configuration enables [Layer 7 (L7) policy](https://istio.io/latest/docs/ambient/usage/l7-features/) enforcement and observability features provided by the waypoint proxy. Applying this label to a namespace ensures that all Pods and Services within that namespace use the specified waypoint proxy.

    To deploy a Service defined in the `service.yaml` file within the test namespace of the Kubernetes cluster specified by the `VCLUSTER_CONTEXT` context, use the following command:

    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:VCLUSTER_CONTEXT]]" create -f service.yaml --namespace [[GLOBAL:TEST_NAMESPACE_NAME]]`}
      language="bash"
      title="Create service"
    />

   To test connectivity between the two NGINX deployments, deploy a temporary Pod equipped with `curl`:

<InterpolatedCodeBlock
  code={`apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: client
    namespace: [[GLOBAL:TEST_NAMESPACE_NAME]]
    labels:
      app: client
  spec:
    replicas: 1
    selector:
      matchLabels:
        app: client
    template:
      metadata:
        labels:
          app: client
      spec:
        containers:
          - name: nginx
            image: nginx:latest
            ports:
              - containerPort: 80`}
  language="yaml"
  title="client_deployment.yaml"
/>

    <InterpolatedCodeBlock
      code={` kubectl --context="[[GLOBAL:VCLUSTER_CONTEXT]]" create -f client_deployment.yaml --namespace [[GLOBAL:TEST_NAMESPACE_NAME]]`}
      language="bash"
      title="Create client deployment"
    />

  </Step>

  ### Configure your desired traffic routing using DestinationRule and VirtualService

  <Step>

    You can create `DestinationRules` and `VirtualService` in the virtual cluster.

    Create a pair that routes our request based on the request path:
    1. Requesting `/v2` endpoint should route our request to pods with `version=v2` label
    2. All other requests are routed to `version=v1` pods.

    Save this `DestinationRule` and `VirtualService` definition, and apply it in the virtual cluster:

<InterpolatedCodeBlock
  code={`apiVersion: networking.istio.io/v1
  kind: DestinationRule
  metadata:
    name: nginx-destination
    namespace: [[GLOBAL:TEST_NAMESPACE_NAME]]
  spec:
    host: nginx-service.[[GLOBAL:TEST_NAMESPACE_NAME]].svc.cluster.local # vCluster translates it to the host service automatically
    subsets:
      - name: v1
        labels:
          version: v1
      - name: v2
        labels:
          version: v2`}
  language="yaml"
  title="destination_rule.yaml"
/>


<InterpolatedCodeBlock
  code={`apiVersion: networking.istio.io/v1
  kind: VirtualService
  metadata:
    name: nginx-service
    namespace: [[GLOBAL:TEST_NAMESPACE_NAME]]
  spec:
    hosts:
      - nginx-service.[[GLOBAL:TEST_NAMESPACE_NAME]].svc.cluster.local # vCluster translates it to the host service automatically
    http:
      - name: "nginx-v2"
        match:
          - uri:
              prefix: "/v2"
        rewrite:
          uri: "/"
        route:
          - destination:
              host: nginx-service.[[GLOBAL:TEST_NAMESPACE_NAME]].svc.cluster.local # vCluster translates it to the host service automatically
              subset: v2
      - name: "nginx-v1"
        route:
          - destination:
              host: nginx-service.[[GLOBAL:TEST_NAMESPACE_NAME]].svc.cluster.local # vCluster translates it to the host service automatically
              subset: v1`}
  language="yaml"
  title="virtual_service.yaml"
/>

    To apply a `DestinationRule` configuration to the virtual cluster specified by the `VCLUSTER_CONTEXT` context, use the following command:
    
    <InterpolatedCodeBlock
      code={` kubectl --context="[[GLOBAL:VCLUSTER_CONTEXT]]" create -f destination_rule.yaml`}
      language="bash"
      title="Create destination rule"
    />

    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:VCLUSTER_CONTEXT]]" create -f virtual_service.yaml`}
      language="bash"
      title="Create virtual service"
    />

  </Step>

  ### Verify that DestinationRule and VirtualService is synced to the host cluster

  <Step>

    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:HOST_CONTEXT]]" get destinationrules --namespace "[[GLOBAL:VCLUSTER_HOST_NAMESPACE]]"`}
      language="bash"
      title="Check destination rule in the host cluster"
    />

    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:HOST_CONTEXT]]" get virtualservices --namespace "[[GLOBAL:VCLUSTER_HOST_NAMESPACE]]"`}
      language="bash"
      title="Check virtual service in the host cluste"
    />

    You should see a `DestinationRule` named `nginx-destination-x-<TEST_NAMESPACE_NAME>-x-vcluster` and VirtualService named `nginx-service-x-<TEST_NAMESPACE_NAME>-x-vcluster`.


  </Step>

  ### Test traffic routing

  <Step>
    Execute a `curl` command from within the client Pod to verify responses from the two NGINX deployments. Depending on the request path, you should receive either "Hello from Nginx Version 1!" or "Hello from Nginx Version 2!" in the response:

    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:VCLUSTER_CONTEXT]]" exec -it -n [[GLOBAL:TEST_NAMESPACE_NAME]] deploy/client -- curl nginx-service/v2
      <!DOCTYPE html>
      <html>
      <head>
        <title>Welcome to nginx v2!</title>
      </head>
      <body>
      <h1>Hello from Nginx Version 2!</h1>
      </body>
      </html>`}
      language="bash"
      title="Query version 2"
    />


    <InterpolatedCodeBlock
      code={`kubectl --context="[[GLOBAL:VCLUSTER_CONTEXT]]" exec -it -n [[GLOBAL:TEST_NAMESPACE_NAME]] deploy/client -- curl nginx-service
      <!DOCTYPE html>
      <html>
      <head>
        <title>Welcome to nginx v1!</title>
      </head>
      <body>
      <h1>Hello from Nginx Version 1!</h1>
      </body>
      </html>`}
      language="bash"
      title="Query version 1"
    />

    Seeing the same output means that request was intercepted by Istio and routed as we specified in the `DestinationRule` and `VirtualService`.

  </Step>

  ### Summary
  <Step>

    Istio integration enables you to re-use one Istio instance from the host cluster for multiple virtual clusters.
    Virtual cluster users can define their own `Gateway`, `DestinationRule` and `VirtualService` without interfering with each other.

  </Step>
</Flow>

## Fields translated during the sync to host

Following fields of `Gateway` are modified by vCluster during the sync to host:
 - reference to the TLS Secret is re-written `spec.servers[*].tls.credentialName`. Secret is automatically synced to the host cluster.
 - namespace, `.` and `*` prefix, followed by `/` is stripped from `spec.servers[*].hosts[*]`, so e.g. `foo-namespace/loft.sh` becomes `loft.sh` in the host object.
 - additional labels `vcluster.loft.sh/managed-by: [YOUR VIRTUAL CLUSTER NAME]` and `vcluster.loft.sh/namespace: [VIRTUAL NAMESPACE]` are automatically added to the `spec.subsets[*].labels`

For additional information how Secret and Service references are translated, read [How does syncing work?](../../configure/vcluster-yaml/sync/README.mdx#how-does-syncing-work)

Following fields of `DestinationRule` are modified by vCluster during the sync to host:
  - reference to the virtual Kubernetes Service is re-written for `spec.host`
  - reference to the TLS Secret in `spec.trafficPolicy.portLevelSettings[*].tls.credentialName` & `spec.trafficPolicy.tls.credentialName` is re-written. Secrets are automatically synced to the host cluster.
  - additional labels

Following fields of `VirtualService` are modified by vCluster during the sync to host:
 - reference to the virtual Kubernetes Service is re-written for:
- `spec.hosts[*]`
- `spec.http[*].route[*].destination.host`
- `spec.http[*].mirrors[*].destination.host`
- `spec.tcp[*].route[*].destination.host`
- `spec.tls[*].route[*].destination.host`

  - reference to the `networking.istio.io/v1` kind: `Gateway` is re-written for:
- `spec.gateways[*]`
- `spec.http[*].match[*].gateways[*]`
- `spec.tls[*].match[*].gateways[*]`
- `spec.tcp[*].match[*].gateways[*]`
  - reference to the `networking.istio.io/v1` kind: `VirtualService` is re-written for:
- `spec.http[*].delegate`

Fields not supported in `VirtualService`:
 - `spec.exportTo`
 - `spec.http[*].match[*].sourceLabels`
 - `spec.http[*].match[*].sourceNamespace`
 - `spec.tcp[*].match[*].sourceLabels`
 - `spec.tcp[*].match[*].sourceNamespace`
 - `spec.tls[*].match[*].sourceLabels`
 - `spec.tls[*].match[*].sourceNamespace`

## Config reference

<IstioPartial />
