import CodeBlock from '@theme/CodeBlock';

import Deploy from '../_partials/deploy/deploy.mdx'
import ProAdmonition from '../_partials/admonitions/pro-admonition.mdx'

<ProAdmonition/>

### Prerequisites

- `kubectl` installed
- `external-secrets` operator installed on your host cluster. See instructions at https://external-secrets.io/latest/

# External secrets integration

To enable the External Secret integration, set the following fields:

```yaml
integrations:
  externalSecrets:
    enabled: true
    sync:
      externalSecrets:
        enabled: true
      stores:
        enabled: true
      clusterStores:
        enabled: true
```

This enables the integration, imports `ClusterSecretStores` from the host cluster into the virtual cluster, and exports namespaced `SecretStores` from the virtual cluster into the host cluster.
**NOTE**: After `SecretStores` have been exported, any changes to them in the host cluster are also reflected into the virtual cluster and vice versa.

Once the virtual cluster is up and running, you can create a `SecretStore` inside the virtual cluster. For this guide, you use the `fake` store type, which prefills data instead of connecting to a remote one.

```yaml
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: fake
spec:
  provider:
    fake:
      data:
      - key: "/foo/bar"
        value: "HELLO1"
        version: "v1"
      - key: "/foo/bar"
        value: "HELLO2"
        version: "v2"
      - key: "/foo/baz"
        value: '{"john": "doe"}'
        version: "v1"
```

Inside the virtual cluster, create the store with `kubectl apply -f fake.yaml`. This should create a corresponding store in the host cluster. You can then create an `ExternalSecret` in the virtual cluster, which references the `SecretStore`.

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: example
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: fake
    kind: SecretStore
  target:
    name: secret-to-be-created
  data:
  - secretKey: foo_bar
    remoteRef:
      key: /foo/bar
      version: v1
  dataFrom:
  - extract:
      key: /foo/baz
      version: v1
```

After the `ExternalSecret` is created in the virtual cluster, the integration creates a corresponding `ExternalSecret` inside the host cluster.
The External Secret Operator running in the host cluster creates the corresponding Kubernetes Secret, and the integration imports this
Secret into the virtual cluster. Running `kubectl get secrets` in the virtual cluster includes the `secret-to-be-created` in its output.
