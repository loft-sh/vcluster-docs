import ProAdmonition from '../_partials/admonitions/pro-admonition.mdx'
import CodeBlock from '@theme/CodeBlock';

<ProAdmonition/>

Patches override the default resource syncing rules in your `vcluster.yaml` configurations.

By default, vCluster [syncs specific resources](https://www.vcluster.com/docs/vcluster/next/configure/vcluster-yaml/sync/) between virtual and host clusters. To modify the sync behavior, you can use patches to specify which fields to edit, exclude, or override during syncing.

For example, vCluster can mirror resources from the virtual cluster to the host cluster—any changes made in the virtual cluster are automatically applied to the host cluster. The same applies in the other direction if syncing is set up from host to virtual cluster.

vCluster supports two patch types:

- [JavaScript expression patch](#javascript-expression-patch): Uses JavaScript ES6 expressions to dynamically modify fields during syncing. You can define how a field changes when syncing from a virtual cluster to a host cluster, or from a host cluster to a virtual cluster.
- [Reference patch](#reference-patch): Modifies specific fields within a resource to point to different resources. If the referenced resource exists in the host cluster, vCluster automatically imports it into the virtual cluster. If the referenced resource exists in the virtual cluster and syncing is configured, vCluster can import it into the host cluster.

:::info Using wildcards in patches
You can apply a wildcard, using an asterisk (`*`) in a specified path, to modify all elements of an array or object.
For instance, `spec.containers[*].name` selects the `name` field of every container in the `spec.containers` array, and `spec.containers[*].volumeMounts[*]` selects all `volumeMounts` for each container.
When using the asterisk (`*`) notation, vCluster applies changes individually to every element that matches the path.
:::

### JavaScript expression patch

A JavaScript expression patch allows you to use JavaScript ES6 expressions to change specific fields when syncing between virtual and host clusters.
This is useful when modifying resource configurations to align with differing environments or naming conventions between clusters. If your clusters use different container name prefixes, a JavaScript expression patch can automatically update them.

:::note JavaScript Runtime
vCluster uses [Goja](https://github.com/dop251/goja), a pure Go implementation of ECMAScript, to evaluate JavaScript expressions. This provides a secure, sandboxed environment for executing your patch expressions.
Refer to [Goja's](https://pkg.go.dev/github.com/dop251/goja) documentation for details on supported JavaScript features and limitations.
:::

You can define a path for <code>{props.path}</code> field in `vcluster.yaml` using the following configuration:

<CodeBlock language="yaml">
{`sync:
  ${props.direction}:
    ${props.resource}:
      enabled: true
      patches:
      - path: ${props.path}
        expression: '"my-prefix-"+value'
        # optional reverseExpression to reverse the change from the host cluster
        # reverseExpression: 'value.slice("my-prefix".length)'`}
</CodeBlock>

In the example:

  - The path targets the <code>{props.path}</code> field to override when syncing to the host cluster. The `*` wildcard applies the patch to each container individually.
  - `"'my-prefix-' + value"` defines a JavaScript expression that prepends `"my-prefix-"` to the <code>{props.path}</code> field in the host cluster.

:::note Reverse sync
You can use the `reverseExpression` field to define how to revert changes when syncing from the host cluster back to the virtual cluster.
For example, add `reverseExpression: {"value.slice('my-prefix'.length)"}` to `vcluster.yaml` to remove the `"my-prefix-"` prefix when syncing back from the host cluster to the virtual cluster in the previous example.
:::

To replace value with a hardcoded one, put the desired value in the quotation marks:
<CodeBlock language="yaml">
  {`sync:
  ${props.direction}:
    ${props.resource}:
      enabled: true
      patches:
      - path: ${props.path}
        expression: '"my-value"'
`}
</CodeBlock>

:::note JavaScript expressions
The JavaScript expression patch supports a limited set of JavaScript features. For example, it does not support `import` statements or other Node.js-specific features. You can use standard JavaScript expressions, functions, and operators.
The expression is evaluated in a sandboxed environment, so it cannot access external resources or the host system.
Also, the JavaScript expression must be a valid ES6 expression. This means it should not contain any statements, only expressions that return a value.

A common use is to use ternary operators to conditionally modify values based on their existence or other criteria.
Another common use is the `optional chaining operator` like in: `value.myfield?.anotherfield || "default-value"`.

**Additional functions available:**
- `atob(encodedData)`: Decodes a base64-encoded string and returns the decoded string. Ex: `atob("bXktdmFsdWU=")` returns `my-value`.
- `btoa(stringToEncode)`: Encodes a string in base64 and returns the encoded string. Ex: `btoa("my-value")` returns `bXktdmFsdWU=`.
- `virtualToHostDNS(virtualSvc)`: Translates a virtual service to its corresponding host FQDN. The domain must follow the format `<name>.<namespace>.svc[.<cluster-domain>]`.
  Ex: `virtualToHostDNS(nginx.default.svc.cluster.local)` returns `nginx-x-default-x-vcluster.vcluster-ns.svc.cluster.local`.

These functions are useful for encoding/decoding values or translating services when syncing between clusters, but be sure a value exists before operating on it:
<CodeBlock language="yaml">
  {`sync:
    toHost:
      ${props.resource}:
        enabled: true
        patches:
        - path: metadata.annotations["encoded-value"]
          expression: 'btoa(value)'
        - path: metadata.annotations["decoded-value"]
          expression: 'atob(value)'
        - path: metadata.annotations["referenced-service"]
          expression: 'virtualToHostDNS(value)'`}
</CodeBlock>
:::

There are two kinds of expression categories in the configuration:
- `expression` — Specifies the synchronization rules from virtual clusters to the host cluster.
Use this to control which resources, fields, or attributes in the virtual clusters are reflected in the host cluster.
- `reverseExpression` — Specifies the synchronization rules from the host cluster to the virtual clusters.
Use this to control how updates or resources in the host cluster are propagated back to the virtual clusters.
:::warning
To achieve bi-directional synchronization, you must define both `expression` and `reverseExpression`.
:::

#### Context variable

The context variable is an object supported in JavaScript expression patches, that provides access to virtual cluster data during syncing. The context object includes the following properties:

* `context.vcluster.name`: Name of the virtual cluster.
* `context.vcluster.namespace`: Namespace of the virtual cluster.
* `context.vcluster.config`: Configuration of the virtual cluster, basically `vcluster.yaml` merged with the defaults.
* `context.hostObject`: Host object (`null` if not available).
* `context.virtualObject`: Virtual object (`null` if not available).
* `context.path`: Matched path on the object, useful when using wildcard path selectors (`*`).

### Reference patch

A reference patch links a field in one resource to another resource. During syncing, vCluster updates the reference and imports the linked resource from the virtual cluster to the host cluster or from the host cluster to the virtual cluster, depending on the sync direction and whether the resource exists.

You can use reference patches to share resources, such as `Secrets` or `ConfigMaps`, between clusters without manually recreating or duplicating them.

For example, if the host cluster contains a secret named `"my-example-secret"`, vCluster automatically imports it into the virtual cluster.

Workloads in the virtual cluster can then use the secret without manual syncing.

You can sync between the virtual cluster and the host cluster by mapping `spec.secretName` to a secret in the host cluster:

<CodeBlock language="yaml">
{`sync:
  toHost:
    ${props.resource}:
      enabled: true
      patches:
      - path: metadata.annotations["my-secret-ref"]
        reference:
          apiVersion: v1
          kind: Secret`}
</CodeBlock>

In the example:

- The code uses a patch to add `metadata.annotations["my-secret-ref"]`
- It references a Secret in the host cluster using the patch and ensures <code>{props.resource}</code> in the host cluster links to the correct Secret.

:::note Reference Patches with Namespace Syncing
If you have enabled syncing namespaces, reference patches are only required if the namespace is part of the patch. You can use the `namespacePath` option to specify the path of the namespace of the reference.
:::
